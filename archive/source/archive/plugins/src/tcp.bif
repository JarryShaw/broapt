module Reass;

%%{  // C segment
#include <limits.h>
#include <stdio.h>
#include <sstream>
#include <string>
#include <vector>

// buffer (from PyPCAPKit, c.f. pcapkit.reassembly.tcp.TCP_Reassembly._buffer)

typedef struct {
    uint64_t first;
    uint64_t last;
} hole_t;

typedef struct {
    uint64_t isn;
    uint64_t len;
    std::string raw;
} part_t;

typedef std::vector<hole_t> hdl_t;

// TCP Reassembly algorithm (c.f. RFC791, RFC815)

class TCP_Reassembly {
    hdl_t HDL;
    part_t BUF{};
    bool FLAG = true;

    public:
        TCP_Reassembly(const char * root, uint64_t ack);
    protected:
        void reassembly(uint64_t seq, uint64_t len, bool fin_rst, std::string payload);
        void submit(const char * root);
    private:
        void write_data(const char * root, std::string data, bool is_part, uint64_t start=0, uint64_t stop=UINT_MAX);
}

TCP_Reassembly::TCP_Reassembly(const char * root) {
    ;
}

void TCP_Reassembly::reassembly(uint64_t seq, uint64_t len, bool fin_rst, std::string PLD) {
    uint64_t DSN = seq;
    if (FLAG) {
        BUF.isn=DSN;
        BUF.raw=PLD;
        BUF.len=len;

        hole_t hole {len, UINT_MAX};
        HDL.push_back(hole);
        FLAG = false;
        return;
    }

    uint64_t LEN, SUM, GAP;
    uint64_t ISN = BUF.isn;
    std::string TMP;
    std::string RAW = BUF.raw;
    if (DSN > ISN) {
        LEN = BUF.len;
        SUM = ISN + LEN;
        if (DSN >= SUM) {
            GAP = DSN - SUM;
            TMP.resize(GAP, '\x00');
            RAW += TMP + PLD;
        } else {
            TMP.resize(0, DSN-ISN);
            RAW += TMP + PLD;
        }
    } else {
        LEN = len;
        SUM = DSN + LEN;
        if (ISN >= SUM) {
            GAP = ISN - SUM;
            TMP.resize(GAP, '\x00');
            RAW = PLD + TMP + RAW;
        } else
            RAW = PLD.substr(0, SUM) + RAW;
    }
    BUF.raw = RAW;
    BUF.len = (uint64_t) RAW.length();

    bool flag = false;
    uint64_t first = seq;
    uint64_t last = first + len;
    for(hdl_t::iterator hole = HDL.begin(); hole != HDL.end(); ++hole) {
        if (first > hole->last)
            continue;
        if (last < hole->first)
            continue;
        HDL.erase(hole);
        if (first > hole->first) {
            hole_t new_hole {hole->first, first-1};
            HDL.insert(hole, new_hole);
            flag = true;
        }
        if ((last < hole->last) && !fin_rst) {
            hole_t new_hole {last+1, hole->last};
            if (flag)
                ++hole;
            HDL.insert(hole, new_hole);
        }
        break;
    }
}

void TCP_Reassembly::submit(const char * root) {
    uint64_t start = 0;
    uint64_t stop = 0;
    std::string data;

    if (HDL.size() > 1) {
        for(hdl_t::iterator hole = HDL.begin(); hole != HDL.end(); ++hole) {
            stop = hole->first;
            data = BUF.raw.substr(start, stop-start);
            if (data.length())
                write_data(root, data, true, start, stop);
            start = hole->last;
        }
        data = BUF.raw.substr(start);
        if (data.length())
            write_data(root, data, true, start, (uint64_t) data.length());
    } else {
        data = BUF.raw;
        if (data.length())
            write_data(root, data, false);
    }
}

void TCP_Reassembly::write_data(const char * root, std::string data, bool is_part, uint64_t start, uint64_t stop) {
    char filename[strlen(root)*2];
    if (is_part)
        sprintf(filename, "%s_%llu-%llu.part", root, start, stop);
    else
        sprintf(filename, "%s.dat", root);

    FILE * fp = fopen(filename, "wb");
    if (fp == NULL)
        exit(EXIT_FAILURE);
    fwrite(data.c_str(), sizeof(char), data.length(), fp);
    fclose(fp);
}

%%}

function reassemble%(s: string%) : string
    %{
    char* rot13 = copy_string(s->CheckString());

    for ( char* p = rot13; *p; p++ )
        {
        char b = islower(*p) ? 'a' : 'A';
        *p  = (*p - b + 13) % 26 + b;
        }

    BroString* bs = new BroString(1, reinterpret_cast<byte_vec>(rot13),
                                  strlen(rot13));
    return new StringVal(bs);
    %}

event tcp_reassembly%(vec: vector of context, ack: count%);
